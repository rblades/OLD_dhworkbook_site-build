<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Shawn Graham">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Regex & the Republic of Texas - HIST3814o Crafting Digital History</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  <link href="../../css/extra.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Regex & the Republic of Texas";
    var mkdocs_page_input_path = "supporting materials/regexex.md";
    var mkdocs_page_url = "/supporting materials/regexex/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> HIST3814o Crafting Digital History</a>
        <a href="#skip-nav">Skip navigation menu</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <label hidden for="search-box" aria-hidden="false">Search Documents
    </label>
    <input id="search-box" type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
  <ul class="current">
    
          
            <li class="toctree-l1">
    
    <a class="" href="../..">Home</a>
      </li>
          
            <li class="toctree-l1">
    
    <a class="" href="../../introduction/crafting-digital-history/">Getting Started</a>
      </li>
          
            <li class="toctree-l1">
    
    <span class="caption-text">1. Open Access Research</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../module-1/Open-Access-Research/">Why you should be open</a>
                </li>
                <li class="">
                    
    <a class="" href="../../module-1/Exercises/">Exercises</a>
                </li>
    </ul>
      </li>
          
            <li class="toctree-l1">
    
    <span class="caption-text">2. Finding Data</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../module-2/Finding Data/">How do we find data?</a>
                </li>
                <li class="">
                    
    <a class="" href="../../module-2/Exercises/">Exercises</a>
                </li>
    </ul>
      </li>
          
            <li class="toctree-l1">
    
    <span class="caption-text">3. Fixing Data</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../module-3/Wrangling Data/">Data is messy</a>
                </li>
                <li class="">
                    
    <a class="" href="../../module-3/Exercises/">Exercises</a>
                </li>
    </ul>
      </li>
          
            <li class="toctree-l1">
    
    <span class="caption-text">4. Analysis</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../module-4/Seeing Patterns/">Seeing Patterns</a>
                </li>
                <li class="">
                    
    <a class="" href="../../module-4/Exercises/">Exercises</a>
                </li>
    </ul>
      </li>
          
            <li class="toctree-l1">
    
    <span class="caption-text">5. Visualization</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../module-5/Humanities Visualization/">Communicating your Findings</a>
                </li>
                <li class="">
                    
    <a class="" href="../../module-5/Exercises/">Exercises (OPTIONAL)</a>
                </li>
    </ul>
      </li>
          
            <li class="toctree-l1">
    
    <a class="" href="../../conclusion/conclusion/">6. Final Thoughts</a>
      </li>
          
            <li class="toctree-l1">
    
    <span class="caption-text">Appendices</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../tei/">Text Encoding Initiative</a>
                </li>
                <li class="">
                    
    <a class="" href="../git-rstudio/">Git in RStudio</a>
                </li>
                <li class="">
                    
    <a class="" href="../regex/">Introduction to Regular Expressions (regex)</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Regex & the Republic of Texas</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#regex-and-the-republic-of-texas">REGEX and the Republic of Texas</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#getting-started">Getting started</a></li>
        
            <li><a class="toctree-l4" href="#the-workflow">The workflow</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../open-refine/">Open Refine</a>
                </li>
                <li class="">
                    
    <a class="" href="../ner/">Stanford Named Entity Recognizer</a>
                </li>
                <li class="">
                    
    <a class="" href="../regex-ner/">Going further with regex</a>
                </li>
                <li class="">
                    
    <a class="" href="../quick-intro-r/">Quick intro to R</a>
                </li>
                <li class="">
                    
    <a class="" href="../cyoa.txt/">Choose Your Own Adventure</a>
                </li>
                <li class="">
                    
    <a class="" href="../geoparsing-w-python.txt/">Geoparsing with Python</a>
                </li>
                <li class="">
                    
    <a class="" href="../glitch/">Glitch</a>
                </li>
                <li class="">
                    
    <a class="" href="../gephi.txt/">Social Network Analysis with Gephi</a>
                </li>
                <li class="">
                    
    <a class="" href="../multimode-networks.txt/">Multimode Networks</a>
                </li>
                <li class="">
                    
    <a class="" href="../graphing-the-net.txt/">Graphing the Net</a>
                </li>
                <li class="">
                    
    <a class="" href="../topicmodel-r-dhbox/">Topic Modeling, DH Box</a>
                </li>
                <li class="">
                    
    <a class="" href="../topicmodel-r-yourmachine/">Topic Modeling, Local</a>
                </li>
                <li class="">
                    
    <a class="" href="../netviz/">Network visualization with igraph</a>
                </li>
                <li class="">
                    
    <a class="" href="../inkscape/">Inkscape</a>
                </li>
                <li class="">
                    
    <a class="" href="../gh-pages/">GitHub Pages</a>
                </li>
                <li class="">
                    
    <a class="" href="../leaflet.txt/">Leaflet</a>
                </li>
    </ul>
      </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">HIST3814o Crafting Digital History</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Appendices &raquo;</li>
        
      
    
    <li>Regex & the Republic of Texas</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/shawngraham/dhworkbook/tree/gh-pages/edit/master/docs/supporting materials/regexex.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <a name="skip-nav" aria-label="Anchor link destination for skipping navigation"></a>
          <div role="main">
            <div class="section">
              
                <h1 id="regex-and-the-republic-of-texas">REGEX and the Republic of Texas</h1>
<p>Regex comes in several different flavours. A good text editor on your own computer like <a href="https://www.sublimetext.com/">Sublime Text</a> or <a href="https://atom.io/">Atom</a> can do Regex searches and replaces from the find-and-replace box; Word cannot do that. Remember, Regex searches for <strong>patterns</strong> in the text. The correspondence of the Republic of Texas was collated into a single volume and published with a helpful index in 1911. It was scanned and OCR'd by Google, and is now available as a text file from the Internet Archive. You can see the OCR'd text at <a href="http://archive.org/stream/diplomaticcorre33statgoog/diplomaticcorre33statgoog_djvu.txt">archive.org</a>. We are going to grab the index from that file, and transform it using regex.</p>
<p>There are several hundred entries in that index. You could clean them up by hand, deleting and cutting and pasting, but with the power of regex, we'll go from this:</p>
<pre><code>Sam Houston to A. B. Roman, September 12, 1842 101
Sam Houston to A. B. Roman, October 29, 1842 101
Correspondence for 1843-1846 —
Isaac Van Zandt to Anson Jones, January 11, 1843 103
</code></pre>

<p>...to nicely CSV-formatted table like this:</p>
<pre><code>Sam Houston, A. B. Roman, September 12 1842
Sam Houston, A. B. Roman, October 29 1842
Isaac Van Zandt, Anson Jones, January 11 1843
</code></pre>

<p>The change doesn't look like much, and you might think to yourself, 'hey, I could just do that by hand'. You could but it'd take you ages, and if you made a mistake somewhere, are you sure you could do this consistently, for a couple of hours at a time? Probably not. Your time is better spent figuring out the search and replace patterns, and then setting your machine loose to implement it.</p>
<p>Data formatted like this could be fed into a network analysis program, for instance, or otherwise visualized and analyzed (which we will do in the next module). Regex as we are going to use in this tutorial allows us to go from unstructured to structured data.</p>
<h2 id="getting-started">Getting started</h2>
<p>In the previous module, we learned how to automatically grab text from sites like <a href="http://search.canadiana.ca/">Canadiana</a>. In this particular exercise today, we'll quickly download the file using <code>curl</code> (it's like wget, though there are some <a href="https://daniel.haxx.se/docs/curl-vs-wget.html">differences between the two commands</a>. It's good to know both).</p>
<ol>
<li>
<p>At the command line, type the following curl command:</p>
<pre><code>$ curl http://archive.org/stream/diplomaticcorre33statgoog/diplomaticcorre33statgoog_djvu.txt &gt; texas.txt
</code></pre>
<p>The <code>curl</code> command downloads the txt file and the the <code>&gt;</code> pushes the result of the command to a file called <code>texas.txt</code>.</p>
</li>
<li>
<p>Open <code>texas.txt</code> with Nano and delete everything except for the index of the list of letters (we just want the index). </p>
<blockquote>
<p>a. To select a lot of text in Nano, you set a starting point (a mark) with ctrl+shift+6 (the 'carat' symbol: ^). </p>
<p>b. Then hit the down arrow on your keyboard, and you will highlight the text. </p>
<p>c. When you've selected everything you want, hit ctrl+k to cut the text.</p>
</blockquote>
<p>That is, you’re looking for the table of letters, starting with ‘Sam Houston to J. Pinckney Henderson, December 31, 1836 51’ and ending with ‘Wm. Henry Daingerfield to Ebenezer Allen, February 2, 1846 1582’. Your file will now have approximately 2000 lines in it.</p>
<p>Notice that there is a lot of text that we are not interested in at the moment: page numbers, headers, footers, or categories. We're going to use regular expressions to get rid of them. What we want to end up with is a spreadsheet that is arranged in three columns:</p>
<pre><code>Sender, Recipient, Date
</code></pre>
</li>
<li>
<p>Scroll down through the text; notice there are many lines which don't include a letter, because they're either header info, or blank, or some other extraneous text. We're going to get rid of all of those lines too.</p>
<p>We want to keep every line that has this information in it: Sender to Recipient, Month, Date, Year, Page.</p>
</li>
<li>
<p>Save the file in nano: ctrl+x, Y, enter </p>
<p><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/4Qf334BqXm4?rel=0" title="Downloading and editing our correspondence" frameborder="0" gesture="media" allowfullscreen></iframe>
<br></p>
</li>
</ol>
<p>WARNING: Regex can be very tricky. When I'm working with regex, I copy and paste some of the text I'm working on into the box at <a href="http://www.regexr.com/">RegExr</a> and fiddle with the pattern until it does what I want. In fact, spend some time looking at their examples before you go any further in this exercise.</p>
<h2 id="the-workflow">The workflow</h2>
<p>We start by finding every line that looks like a reference to a letter, and put a tilde (a <code>~</code> symbol) at the beginning of it so we know to save it for later. Next, we get rid of all the lines that don't start with tildes, so that we're left with only the relevant text. After this is done, we format the remaining text by putting commas in appropriate places, so we can import it into a spreadsheet and do further edits there.</p>
<p>We're going to use the <code>sed</code> and <code>grep</code> commands at the command prompt in our DH Box. These commands work differently to achieve different goals.</p>
<ul>
<li>
<p>sed (where the 's' means 'stream' and 'ed' means 'editor') works by first identifying text that matches a pattern, and then swapping in the text we want to have, like the following:</p>
<pre><code>$ sed 's/old text/new text/g' filename
</code></pre>
</li>
<li>
<p>grep works in the following way:</p>
<pre><code>$ grep 'PATTERN WE WANT' inputfile
</code></pre>
<p>The above will print the results to the screen. If we want to redirect the results to a new file, we add this to the end: <code>&gt; outputfile</code>.</p>
</li>
</ul>
<h3 id="step-one-identifying-lines-that-have-correspondence-senders-and-receivers-in-them">Step One: Identifying lines that have correspondence Senders and Receivers in them</h3>
<p><strong>Discussion:</strong> Read in full before doing any manipulation of your text!</p>
<p><strong>If you were using a text editor on your own computer, you would modify your regex appropriately:</strong></p>
<ul>
<li><strong>Notepad++:</strong> press ctrl+f or search-&gt;find to open the find dialogue box. In that box, go to the 'Replace' tab, and check the radio box for 'Regular expression' at the bottom of the search box. </li>
<li><strong>TextWrangler:</strong> hit command+f to open the find and replace dialogue box. Tick off the ‘grep’ radio button (which tells TextWrangler that we want to do a regex search) and the ‘wraparound’ button (which tells TextWrangler to search everywhere). </li>
<li><strong>Sublime text:</strong> command+f (Mac) / ctrl+f (Windows) opens the 'find' box (and shift+command+f (Mac) / shift+ctrl+f (Windows) opens find <strong>and</strong> replace). Tick the <code>.\*</code> button to tell Sublime we're working with regular expressions.</li>
</ul>
<p><strong>However, we're going to use the two commands sed and grep at the command prompt in DH Box</strong>.</p>
<p>Remember from our basic introduction that there's a way to see if the word "to" appears in full. </p>
<ol>
<li>
<p>Type <code>$ grep '\bto\b' texas.txt</code></p>
<p>The results print out to the screen. This command finds every instance of the word "to" (and not, for instance, also ‘potato’ or ‘tomorrow’ &mdash; try <code>grep 'to' texas.txt</code> instead to see the difference).</p>
<p>We don't just want to find "to", but the entire line that contains it. We assume that every line that contains the word “to” in full is a line that has relevant letter information, and every line that does not is one we do not need. </p>
<p>You learned earlier that the query <code>.+</code> returns any amount of text, no matter what it says. Thus, the pattern that we will build when we are ready to use the sed command will include <code>.+\bto\b.+</code> &mdash; therefore, we edit every line which includes the word "to" in full (no matter what comes before or after it) and we do not edit any of the lines which do not contain "to".</p>
<p>As mentioned earlier, we want to add a tilde <code>~</code> before each of the lines that look like letters, so we can save them for later. This involves the find-and-replace function, and a query identical to the one before, but with parentheses around it, so it looks like the following</p>
<pre><code>(.+\&lt;to\&gt;)
</code></pre>
<p>and the entire line is placed within a parenthetical group. Since this the first group in our search expression, we can replace that group with <code>\1</code> and put the tilde in front of it like so: <code>~\1</code>.</p>
</li>
<li>
<p>Copy and paste some of your text into <a href="http://RegExr.com">RegExr.com</a>. </p>
</li>
<li>
<p>Write your regular expression (ie. what you're trying to find), and your substitution (ie. what you're replacing with) in the RegExr interface. </p>
</li>
<li>
<p>Once you're satisfied that you've got it right, we put the complete expression into our sed command:</p>
<pre><code>$ sed -r -i.bak 's/(.+\bto\b.+)/~\1/g' texas.txt
</code></pre>
<p>Where:</p>
<ul>
<li><code>-r</code> means extended regex. This saves us from having to 'escape' certain characters.</li>
<li><code>-i.bak</code> means make a backup of the original input file, in case things go wrong.</li>
<li><code>-'s/old-pattern/newpattern/g'</code> is how we find and switch what we're looking for. The final <code>g</code> means 'globally', everywhere in the file.</li>
<li><code>texas.txt</code> is the filename that we're looking to change.</li>
</ul>
<p><br />
When you hit enter, the computer seems to pause for a moment, and then gives you the command prompt again. </p>
</li>
<li>
<p>Type <code>ls</code> and you'll see that a new file, <code>texas.txt.bak</code> has been created.</p>
</li>
<li>
<p>Type <code>nano texas.txt</code> and examine the file. You should now have <code>~</code> (tilde characters) at the start of each entry of the index!</p>
<p><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/RQNyjSyQzjg?rel=0" title="Editing our file with grep and sed in the command line" frameborder="0" gesture="media" allowfullscreen></iframe>
<br></p>
</li>
</ol>
<p>If for some reason your file does not have the tidles, or you've mangled your original file, you can replace <code>texas.txt</code> with the backup file you made like the following: <code>$ mv old-file-name new-file-name</code>, thus, <code>$ mv texas.txt.bak texas.txt</code>. Use Nano to confirm that you're back to where you needed to be, and try again.</p>
<h3 id="step-two-removing-lines-that-arent-relevant">Step Two: Removing lines that aren’t relevant</h3>
<p><strong>Discussion</strong></p>
<p>After running the find-and-replace, you should note your document now has most of the lines with tildes in front of it, and a few which do not. The next step is to remove all the lines that do not include a tilde. <strong>If you were using a text editor on your own computer</strong>, the search string to find all lines which don't begin with tildes is <code>\n[^~].+</code></p>
<p>A <code>\n</code> at the beginning of a query searches for a new line, which means it's going to start searching at the first character of each new line. <strong>However, given the evolution of computing, it may well be that this won’t quite work on your system.</strong> For instance, Linux based systems use <code>\n</code> for a new line, while Windows often uses <code>\r\n</code>, and older Macs just use <code>\r</code>. These are the sorts of things that can drive us crazy, and so we digital historians need to keep that in mind! Since this will likely cause much frustration, your safest bet will be to save a copy of what you are working on, and then experiment to see what gives you the best result. In most cases, the syntax will be the following:</p>
<pre><code>\r\n[^~].+
</code></pre>

<p>Within a set of square brackets <code>[]</code> the carrot <code>^</code> means search for anything that isn't within these brackets (in this case, the tilde <code>~</code>). The  <code>.+</code> as before means search for every remainding character in the line as well. All together, the query returns any full line which does not begin with a tilde; that is, the lines we did not mark as looking like letters.</p>
<p>By finding all <code>\r\n[^~].+</code> and replacing it with nothing, you effectively delete all the lines that don't look like the index entries. What you're left with is a series of entries and a series of blank lines.</p>
<p><strong>But DH Box makes the regex process so much easier.</strong></p>
<p>We are simply going to get grep to find all the lines that have a tilde in them, and write them to a new file like the following:</p>
<pre><code>    $ grep '~' texas.txt &gt; index.txt
</code></pre>
<p>Use Nano to confirm that this is true. </p>
<p>Wasn't that easy?</p>
<p><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/TRI46x2zp2U?rel=0" title="Removing irrelevant lines in our correspondence" frameborder="0" gesture="media" allowfullscreen></iframe>
<br></p>
<h3 id="step-three-transforming-into-csv-format">Step Three: Transforming into CSV format</h3>
<p><strong>Discussion</strong></p>
<p>To turn this text file into a spreadsheet, we'll want to separate it out into one column for Sender, one for Recipient, and one for Date, each separated by a single comma. Notice that most lines have extraneous page numbers attached to them; we can get rid of those with regular expressions. There's also usually a comma separating the month-date and the year, which we'll get rid of as well. In the end, the first line should go from looking like the following:</p>
<pre><code>    ~Sam Houston to J. Pinckney Henderson, December 31, 1836 51
</code></pre>
<p>to looking like the following:</p>
<pre><code>    Sam Houston, J. Pinckney Henderson, December 31 1836
</code></pre>
<p>such that each data point is in its own column.</p>
<p>You will start by removing the page number after the year and the comma between the year and the month-date. To do this, first locate the year on each line by using the regex:</p>
<pre><code>    [0-9]{4}
</code></pre>
<p>We can find any digit between 0 and 9 by searching for <code>[0-9]</code>, and <code>{4}</code> will find four of them together. Now extend that search out by appending <code>.+</code> to the end of the query; as seen before, it will capture the entire rest of the line. The following query:</p>
<pre><code>    [0-9]{4}.+
</code></pre>
<p>will return, for example, "1836 51", "1839 52", and "1839 53" from the first three lines of the text. We also want to capture the comma preceding the year, so add a comma and a space before the query, resulting in the following: </p>
<pre><code>     , [0-9]{4}.+
</code></pre>
<p>which will return ", 1836 51", ", 1839 52", etc.</p>
<p>The next step is making the parenthetical groups which will be used to remove parts of the text with find-and-replace. In this case, we want to remove the comma and everything after 'year', but not the year or the space before it. Thus our query will look like the following:</p>
<pre><code>    (,)( [0-9]{4})(.+)
</code></pre>
<p>with the comma as the first group <code>"\1"</code>, the space and the year as the second <code>"\2"</code>, and the rest of the line as the third <code>"\3"</code>.  Given that all we care about retaining is the second group (we want to keep the year, but not the comma or the page number), what will the <strong>replace</strong> look like?</p>
<p>Find the dates using a regex, and replace so that only the <strong>second</strong> group in the expression is kept. You might want to consult the introduction to regex again before you execute this one.</p>
<p>Remember, the first part of the sed command will be: <code>sed -r -i.bak</code> then the pattern to find, the pattern to replace with, and the file name. You want to use sed on the new <code>index.txt</code> file you made. Can you devise the right pattern? It will resemble the following:</p>
<pre><code>    $ sed -r -i.bak the-pattern-to-find the-patter-to-replace-with index.txt
</code></pre>
<p><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/syyFk2rhSc8?rel=0" title="Transforming our file into CSV format" frameborder="0" gesture="media" allowfullscreen></iframe>
<br></p>
<h3 id="step-four-removing-the-tildes">Step Four: Removing the tildes</h3>
<ul>
<li>Find the tildes that we used to mark off our text of interest, and replace them with nothing to delete them.</li>
</ul>
<p><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/eg3p5BN1oKs?rel=0" title="Removing the tildes before each line" frameborder="0" gesture="media" allowfullscreen></iframe>
<br></p>
<h3 id="step-five-separating-senders-and-receivers">Step Five: Separating Senders and Receivers</h3>
<p><strong>Discussion</strong></p>
<p>Finally, to separate the Sender and Receiver by a comma, we find all instances of the word "to" and replace it with a comma. Although we used <code>\b</code> and <code>\b</code> to denote the beginning and end of a word earlier in the lesson, we don't exactly do that here. We include the space preceding “to” in the regular expression, as well as the <code>\b</code> to denote the word ending. Once we find instances of the word and the space preceding it, <code>to\b</code> we replace it with a comma <code>,</code>.</p>
<ul>
<li>Devise the regex to find the word, and replace with a comma.</li>
</ul>
<p><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ESj9_rYQ2jw?rel=0" title="Separating Senders and Receivers" frameborder="0" gesture="media" allowfullscreen></iframe>
<br></p>
<h3 id="step-six-cleaning-up">Step Six: Cleaning up</h3>
<p><strong>Discussion</strong></p>
<p>You may notice that some lines still do not fit our criteria. Line 22, for example, reads "Abner S. Lipscomb, James Hamilton and A. T. Bumley, AugUHt 15, ". It has an incomplete date; we don't need to worry about these for our purposes. </p>
<p>More worrisome are lines, like 61 "Copy and summary of instructions United States Department of State, " which include none of the information we want. We can get rid of these lines later in a spreadsheet.   </p>
<p>The only non-standard lines we need to worry about with regular expressions are the ones with more than 2 commas, like line 178, "A. J. Donelson, Secretary of State [Allen,. arf interim], December 10 1844". Notice that our second column, the name of the Recipient, has a comma inside of it. If you were to import this directly into a spreadsheet, you would get four columns, one for Sender, two for Recipient, and one for date, which would break any analysis you would then like to run. Unfortunately these lines need to be fixed by hand, but happily regular expressions make finding them easy. The following query:</p>
<p><code>.+,.+,.+,</code></p>
<p>will show you every line with more than 2 commas, because it finds any line that has any set of characters, then a comma, then any other set, then another comma, and so forth. Use grep to find these.  </p>
<p>Lastly, at the top of the file, add a new line that simply reads "Sender, Recipient, Date". These will be the column headers. Make a copy as a CSV file by using the <code>cp</code> command in the DH Box command line like the following:</p>
<pre><code>    $ cp index.txt cleaned-correspondence.csv
</code></pre>
<p><strong>Congratulations!</strong></p>
<p><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/4bLRLWlQYG0?rel=0" title="Cleaning our file" frameborder="0" gesture="media" allowfullscreen></iframe>
<br></p>
<p>You've now used regex to extract, transform, and clean historical text. As a CSV file, you could now load this data into a network analysis program such as <a href="http://gephi.org">Gephi</a> to explore the ramifications of this correspondence network. Upload your file to your repository, and make a note of the original location of the file, the transformations that you've done, and the date/time. You will be using your <code>cleaned-correspondence.csv</code> file in the next exercise using <a href="../open-refine/"><strong>Open Refine</strong></a>, where we'll sort out some of the messy OCR (fixing names, and so on).</p>
<h4 id="regex-patterns-for-step-three-to-step-six">Regex patterns for Step Three to Step Six</h4>
<p>The pattern you want in step three is</p>
<pre><code>    $ sed -r -i.bak 's/(,)( [0-9]{4})(.+)/\2/g' index.txt
</code></pre>
<p>The pattern for step four is</p>
<pre><code>    $ sed -r -i.bak 's/~//g' index.txt
</code></pre>
<p>The pattern for step five is</p>
<pre><code>    $ sed -r -i.bak 's/(\b to \b)/,/g' index.txt
</code></pre>
<p>The pattern for step six is</p>
<pre><code>    $ grep -E ".+,.+,.+," index.txt
</code></pre>
<p><strong>HOWEVER</strong>, in DH Box, the command will use <code>-r</code> instead of <code>-E</code> like the following:</p>
<pre><code>    $ grep -r ".+,.+,.+," index.txt
</code></pre>
<p>The <code>-E</code> tells grep to treat the pattern as an extended regex (regex with a few more bells and whistles). On DH Box, the flag would be <code>-r</code>.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../open-refine/" class="btn btn-neutral float-right" title="Open Refine"/>Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../regex/" class="btn btn-neutral" title="Introduction to Regular Expressions (regex)"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    <!-- Copyright etc -->
    </p>
  </div>

The Crafting Digital History site is built with <a href="http://www.mkdocs.org">MkDocs</a> using a theme provided by <a href="https://readthedocs.org">Read the Docs</a>. All documents are available on <a href="https://github.com/shawngraham/dhworkbook/tree/gh-pages"> GitHub</a>. I thank Reclaim Hosting for their help, support, and example in getting this site up and running.
</footer>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/fitvids/1.1.0/jquery.fitvids.min.js"></script>
<script>
  $(document).ready(function(){
    // Target your .container, .wrapper, .post, etc.
    $(".section").fitVids();
  });
</script>
    
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/shawngraham/dhworkbook/tree/gh-pages" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../regex/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../open-refine/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../../js/theme.js"></script>

</body>
</html>
